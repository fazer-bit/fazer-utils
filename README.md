
# fazer-utils

Пополняемый набор полезных утилит.

### Лицензия
>* MIT
### Инсталляция
    pip install git+https://github.com/fazer-bit/fazer-utils.git
## Утилиты
### timers
>* **TimerPlus**
>
>       from fazer_utils.timers import TimerPlus
>    
>       tm = TimerPlus(10)  # 10 секунд при инициализации.
>       tm.set_sec(5)  # изменить количество секунд на 5.
>       tm.restart()  # обнулить таймер и запустить вновь.
>       res = tm.get_bool()  # возвратит False, если прошло менее 5 секунд
>                             # или True, если более.        
>       res = tm.get_sec()  # возвратит положительное количество секунд, которое 
>                            # сталось до достижения временной отметки
>                            # или отрицательное, если отметка пройдена.
> После обнуления таймера сразу же запускается новый отсчёт.
> При запросе отдаёт False, если указанное количество секунд не достигнуто 
> или True, если временная отметка пройдена.

> * **TimerMinus**
>
> Полный аналог **TimerPlus**, за исключением того, что 
> **get_bool()** отдаёт **True**, если временная отметка не достигнута и
> **False** в случае прохождения.


>* **TimerStep**
>
>       from fazer_utils.timers import TimerStep
>    
>       tm = TimerStep(1, 50, 1.5)  # минимум=1, максимум=50, множитель=1.5
>       tm.set_timer(5, 30, 2)  # изменить настройки таймера.
>       tm.restart()  # начать новый отсчёт с минимума.
>       tm.step()  # начать новый отсчёт с текущий * множитель.
>       res = tm.get_bool()  # возвратит False, если текущая временная 
>                            # отметка не достигнута или True, если преодалена.        
>       res = tm.get_sec()  # возвратит положительное количество секунд, которое 
>                           # сталось до достижения временной отметки
>                           # или отрицательное, если отметка пройдена.
> Таймер начинает новый отсчёт с минимума. При применении метода **step()**
> таймер перезапускается с увеличенным промежутком времени, который 
> высчитывается, как текущий * множитель. При достижении текущим промежутком
> максимума увеличение прекращается.
> Метод **restart()** перезапускает таймер с минимума.
> **TimerStep** полезен, как таймаут, при множественных ошибках подключения к сети.

>* **TimerLast**
>
>       from fazer_utils.timers import TimerLast
>    
>       tm = TimerLast()
>       res = tm.get_sec()  # возвратит положительное количество секунд
>                           # прошедшее с момента последнего запроса.
> Таймер позвращает время в секундах между текущим и предыдущим 
> запросами **get_sec()**